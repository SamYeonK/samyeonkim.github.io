var store = [{
        "title": "3Sum",
        "excerpt":"Problem Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note The solution set must not contain duplicate triplets. Example 1 2...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/3sum/",
        "teaser":null},{
        "title": "4Sum II",
        "excerpt":"Problem Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/4sum_ii/",
        "teaser":null},{
        "title": "Add and Search Word - Data structure design",
        "excerpt":"Problem Design a data structure that supports the following two operations: 1 2 void addWord(word) boolean search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example 1 2 3 4 5 6...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/add_search_word/",
        "teaser":null},{
        "title": "Add Two Numbers",
        "excerpt":"Problem You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/add_two_numbers/",
        "teaser":null},{
        "title": "Balanced Binary Tree",
        "excerpt":"Problem Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1 1 2 3 4 5 6 7...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/balanced_binary_tree/",
        "teaser":null},{
        "title": "Binary Search",
        "excerpt":"Problem Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1. Example 1 1 2 3 Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation:...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/binary_search/",
        "teaser":null},{
        "title": "Binary Search Tree Iterator",
        "excerpt":"Problem Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Example 1 2 3 4 5 6 7 8 9 10 BSTIterator iterator = new BSTIterator(root); iterator.next();...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/binary_search_tree_iterator/",
        "teaser":null},{
        "title": "Binary Tree Inorder Traversal",
        "excerpt":"Problem Given a binary tree, return the inorder traversal of its nodes’ values. Example 1 2 3 4 5 6 7 8 Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] My Answer ( Recursive ) 재귀로 해결 solver 함수에서 결과 리스트에 추가 하는 순서를 left -&gt; node -&gt; right...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/binary_tree_inorder_traversal/",
        "teaser":null},{
        "title": "Binary Tree Level Order Traversal",
        "excerpt":"Problem Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). Example 1 2 3 4 5 6 7 8 9 10 11 12 Input: [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 Output: [ [3], [9,20],...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/binary_tree_level_order_traversal/",
        "teaser":null},{
        "title": "Binary Tree Postorder Traversal",
        "excerpt":"Problem Given a binary tree, return the postorder traversal of its nodes’ values. Example 1 2 3 4 5 6 7 8 Input: [1,null,2,3] 1 \\ 2 / 3 Output: [3,2,1] My Answer ( Recursive ) 재귀로 해결 solver 함수에서 결과 리스트에 추가 하는 순서를 left -&gt; right -&gt; node...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/binary_tree_postorder_traversal/",
        "teaser":null},{
        "title": "Binary Tree Preorder Traversal",
        "excerpt":"Problem Given a binary tree, return the preorder traversal of its nodes’ values. Example 1 2 3 4 5 6 7 8 Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,2,3] My Answer ( Recursive ) 재귀로 해결 solver 함수에서 결과 리스트에 추가 하는 순서를 node -&gt; left -&gt; right...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/binary_tree_preorder_traversal/",
        "teaser":null},{
        "title": "Climbing Stairs",
        "excerpt":"Problem You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Given n will be a positive integer. Example 1 1 2 3 4...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/climbing_stairs/",
        "teaser":null},{
        "title": "Combinations",
        "excerpt":"Problem Given two integers n and k, return all possible combinations of k numbers out of 1 … n. Example 1 2 3 4 5 6 7 8 9 10 Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] My Answer 재귀를 이용해서...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/combinations/",
        "teaser":null},{
        "title": "Construct Binary Tree from Inorder and Postorder Traversal",
        "excerpt":"Problem Given inorder and postorder traversal of a tree, construct the binary tree Note You may assume that duplicates do not exist in the tree. Example 1 2 3 4 5 6 7 8 9 Input: inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Output: 3 / \\ 9 20 / \\...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/construct_binarytree_from_inorder_n_postorder_traversal/",
        "teaser":null},{
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "excerpt":"Problem Given preorder and inorder traversal of a tree, construct the binary tree. Note You may assume that duplicates do not exist in the tree. Example 1 2 3 4 5 6 7 8 9 Input: preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Output: 3 / \\ 9 20 / \\...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/construct_binarytree_from_preorder_n_inorder_traversal/",
        "teaser":null},{
        "title": "Container With Most Water",
        "excerpt":"Problem Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/container_with_most_water/",
        "teaser":null},{
        "title": "Contains Duplicate",
        "excerpt":"Problem Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1 1 2 Input: [1,2,3,1] Output: true Example 2 1 2...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/contains_duplicate/",
        "teaser":null},{
        "title": "Contains Duplicate II",
        "excerpt":"Problem Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1 1 2 Input: nums = [1,2,3,1], k...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/contains_duplicate_ii/",
        "teaser":null},{
        "title": "Contains Duplicate III",
        "excerpt":"Problem Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. Example 1 1 2 Input:...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/contains_duplicate_iii/",
        "teaser":null},{
        "title": "Convert Recursion to Iteration",
        "excerpt":"Definition 재귀적으로 알고리즘을 구현하는것은 좋은 접근이나, 다음과 같은 이유에 의해서 재귀적으로 구현 못 하는경우가 발생한다. Stackoverflow의 발생 재귀적인 알고리즘을 제대로 구현 하지 못했을때, Stackoverflow를 발생시킬 여지가 있다. 효율성 재귀적인 함수 호출은 System Stack에 추가적인 메모리 할당이 요구 된다. 간혹 중복 계산의 문제가 발생할 수 있다. 예를 들어 Pascal’s Triangle 복잡성...","categories": ["LeetCode"],
        "tags": ["LeetCode","Article"],
        "url": "/leetcode/convert_recursion_to_iteration/",
        "teaser":null},{
        "title": "Convert Sorted Array to Binary Search Tree",
        "excerpt":"Problem Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/convert_sorted_array_to_binary_search_tree/",
        "teaser":null},{
        "title": "Delete Node in a BST",
        "excerpt":"Problem Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/delete_node_in_bst/",
        "teaser":null},{
        "title": "Design HashMap",
        "excerpt":"Problem Design a HashMap without using any built-in hash table libraries. To be specific, your design should include these functions: put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key) : Returns the value to which the...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/design_hashmap/",
        "teaser":null},{
        "title": "Design HashSet",
        "excerpt":"Problem Design a HashSet without using any built-in hash table libraries. To be specific, your design should include these functions: add(value) : Insert a value into the HashSet. contains(value) : Return whether the value exists in the HashSet or not. remove(value) : Remove a value in the HashSet. If the...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/design_hashset/",
        "teaser":null},{
        "title": "Fibonacci Number",
        "excerpt":"Problem The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, 1 2 F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2),...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/fibonacci_number/",
        "teaser":null},{
        "title": "Find Duplicate Number",
        "excerpt":"Problem Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1 1 2 Input: [1,3,4,2,2] Output: 2 Example 2...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/find_duplicate_number/",
        "teaser":null},{
        "title": "Find Duplicate Subtrees",
        "excerpt":"Problem Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1 2 3 4 5 6 7...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/find_duplicate_subtrees/",
        "teaser":null},{
        "title": "Find K Closest Elements",
        "excerpt":"Problem Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred. Example 1 1 2 Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4]...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/find_k_closest_elements/",
        "teaser":null},{
        "title": "FInd K-th Smallest Pair Distance",
        "excerpt":"Problem Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. Example 1 2 3 4 5 6 7 8 9 10 Input: nums = [1,3,1] k = 1 Output:...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/find_k_th_smallest_pair_distance/",
        "teaser":null},{
        "title": "Find Minimum in Rotated Sorted Array",
        "excerpt":"Problem Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1 1 2 Input: [3,4,5,1,2] Output: 1 Example 2 1 2 Input: [4,5,6,7,0,1,2] Output:...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/find_minimum_in_rotated_sorted_array/",
        "teaser":null},{
        "title": "Find Minimum in Rotated Sorted Array II",
        "excerpt":"Problem Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1 1 2 Input: [1,3,5] Output: 1 Example 2 1 2 Input: [2,2,2,0,1] Output: 0 Note This is...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/find_minimum_in_rotated_sorted_array_ii/",
        "teaser":null},{
        "title": "Find Peak Element",
        "excerpt":"Problem A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine....","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/find_peak_element/",
        "teaser":null},{
        "title": "Find Smallest Letter Greater than Target",
        "excerpt":"Problem Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target. Letters also wrap around. For example, if the target is target = ‘z’ and letters = [‘a’, ‘b’],...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/find_smallest_letter_greater_target/",
        "teaser":null},{
        "title": "First Bad Version",
        "excerpt":"Problem You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/first_bad_version/",
        "teaser":null},{
        "title": "First Unique Character in s String",
        "excerpt":"Problem Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Example 1 1 2 Input: \"leetcode\" Output: 0 Example 2 1 2 Input: \"loveleetcode\" Output: 2 Note You mau assume the string contain only lowercase letters. My Answer HashMap을...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/first_unique_char_in_string/",
        "teaser":null},{
        "title": "Generate Parenthesis",
        "excerpt":"Problem Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example 1 2 3 4 5 6 7 8 9 Input: 3 Output: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] My Answer ( Recursive ) 재귀를 이용해서 해결 1 2 3 4 5 6...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/generate_parenthesis/",
        "teaser":null},{
        "title": "Group Anagrams",
        "excerpt":"Problem Given an array of strings, group anagrams together. Example 1 2 3 4 5 6 7 Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Output: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] Note All inputs will be in lowercase. The order of your output does not matter. My Answer HashMap을 이용하자. 문자열의...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/group_anagrams/",
        "teaser":null},{
        "title": "Guess Number Higher or Lower",
        "excerpt":"Problem We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num)...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/guess_number_higher_or_lower/",
        "teaser":null},{
        "title": "Happy Number",
        "excerpt":"Problem Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/happy_number/",
        "teaser":null},{
        "title": "Implement Trie (Prefix Tree)",
        "excerpt":"Problem Implement a trie with insert, search, and startsWith methods. Example 1 2 3 4 5 6 7 8 Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // returns true trie.search(\"app\"); // returns false trie.startsWith(\"app\"); // returns true trie.insert(\"app\"); trie.search(\"app\"); // returns true Note You may assume that all inputs are...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/implement_trie/",
        "teaser":null},{
        "title": "Insert into a Binary Search Tree",
        "excerpt":"Problem Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST....","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/insert_into_binary_search_tree/",
        "teaser":null},{
        "title": "Intersection of Two Arrays",
        "excerpt":"Problem Given two arrays, write a function to compute their intersection. Note Each element in the result must be unique The result can be in any order. Example 1 1 2 Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2 1 2 Input: nums1 = [4,9,5], nums2 =...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/intersection_of_two_arrays/",
        "teaser":null},{
        "title": "Intersection of Two Arrays II",
        "excerpt":"Problem Given two arrays, write a function to compute their intersection. Note Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Example 1 1 2 Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/intersection_of_two_arrays_ii/",
        "teaser":null},{
        "title": "Isomorphic Strings",
        "excerpt":"Problem Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/isomorphic_strings/",
        "teaser":null},{
        "title": "Jewels and Stones",
        "excerpt":"Problem You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/jewels_stones/",
        "teaser":null},{
        "title": "Kth Largest Element in a Stream",
        "excerpt":"Problem Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/kth_largest_element_stream/",
        "teaser":null},{
        "title": "K-th Symbol in Grammar",
        "excerpt":"Problem On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/kth_symbol_in_grammar/",
        "teaser":null},{
        "title": "Largest Rectangle in Histogram",
        "excerpt":"Problem Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/largest_rectangle_in_histogram/",
        "teaser":null},{
        "title": "Letter Combinations of a Phone Number",
        "excerpt":"Problem Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example 1 2 Input: \"23\" Output: [\"ad\",...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/letter_combination_phone/",
        "teaser":null},{
        "title": "Longest Palindromic Substring",
        "excerpt":"Problem Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1 1 2 3 Input: \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example 2 1 2 Input: \"cbbd\" Output: \"bb\" My Answer 문자열을...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/longest_palindromic_substring/",
        "teaser":null},{
        "title": "Longest Substring Without Repeating Characters",
        "excerpt":"Problem Given a string, find the length of the longest substring without repeating characters. Example 1 1 2 3 Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2 1 2 3 Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/longest_substring_without_repeating_characters/",
        "teaser":null},{
        "title": "Lowest Common Ancestor of a Binary Tree",
        "excerpt":"Problem Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/lowest_common_ancestor_of_a_binarytree/",
        "teaser":null},{
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "excerpt":"Problem Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/lowest_common_ancestor_of_a_bst/",
        "teaser":null},{
        "title": "Maximum XOR of Two Numbers in an Array",
        "excerpt":"Problem Given a non-empty array of numbers, Find the maximum result of XOR , where 0 ≤ i, j &lt; n. Could you do this in O(n) runtime? Example 1 2 3 Input: [3, 10, 5, 25, 2, 8] Output: 28 Explanation: The maximum result is 5 ^ 25 =...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/max_xor_two_numbers_in_array/",
        "teaser":null},{
        "title": "Maximum Depth of Binary Tree",
        "excerpt":"Problem Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. A leaf is a node with no children. Note Note that in some languages such as Java, there is...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/maximum_depth_of_binary_tree/",
        "teaser":null},{
        "title": "Maximum Depth of N-ary Tree",
        "excerpt":"Problem Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/maximum_depth_of_n_ary_tree/",
        "teaser":null},{
        "title": "Median of Two Sorted Arrays",
        "excerpt":"Problem There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1 1 2 3 4 nums1 =...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/median_of_two_sorted_arrays/",
        "teaser":null},{
        "title": "Merge Sorted Array",
        "excerpt":"Problem Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n)...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/merge_sorted_array/",
        "teaser":null},{
        "title": "Merge Two Sorted Lists",
        "excerpt":"Problem Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example 1 2 Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 My Answer 재귀로 구현 base case 는 l1, l2 둘다 null일때 l1, l2...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/merge_two_sorted_lists/",
        "teaser":null},{
        "title": "Minimum Index Sum of Two Lists",
        "excerpt":"Problem Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/min_idx_sum_two_lists/",
        "teaser":null},{
        "title": "N-arty Tree Level Order Traversal",
        "excerpt":"Problem Given an n-ary tree, return the level order traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1 1 2 3 4 5 6 7 8 1 / | \\...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/n_ary_tree_levelorder_traversal/",
        "teaser":null},{
        "title": "N-ary Tree Postorder Traversal",
        "excerpt":"Problem Given an n-ary tree, return the postorder traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1 1 2 3 4 5 6 7 8 1 / | \\ 3...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/n_ary_tree_postorder_traversal/",
        "teaser":null},{
        "title": "N-ary Tree Preorder Traversal",
        "excerpt":"Problem Given an n-ary tree, return the preorder traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1 1 2 3 4 5 6 7 8 1 / | \\ 3...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/n_ary_tree_preorder_traversal/",
        "teaser":null},{
        "title": "N-Queens II",
        "excerpt":"Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example 1 2 3 4 5 6 7 8 9 10 11 12...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/n_queens_ii/",
        "teaser":null},{
        "title": "Palindrome Pairs",
        "excerpt":"Problem Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. Example 1 1 2 3 Input: [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"] Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"] Example 2...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/palindrome_pairs/",
        "teaser":null},{
        "title": "Pascal's Triangle",
        "excerpt":"Problem Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle. Example 1 2 3 4 5 6 7 8 9 Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] My Answer level이 1일땐 원소가 1 하나 밖에 없는 리스트 이다. level이 2이상일땐 리스트의 앞, 뒤로 1을...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/pascals_triangle/",
        "teaser":null},{
        "title": "Pascals Triangle II",
        "excerpt":"Problem Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle. Note that the row index starts from 0. Example 1 2 Input: 3 Output: [1,3,3,1] My Answer rowIndex의 이전 row의 리스트를 구하고, 그 리스트를 기반으로 새로운 row를 만든다. 1 2 3...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/pascals_triangle_ii/",
        "teaser":null},{
        "title": "Path Sum",
        "excerpt":"Problem Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note A leaf is a node with no children. Example 1 2 3 4 5 6 7 8 9 10...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/path_sum/",
        "teaser":null},{
        "title": "Permutations",
        "excerpt":"Problem Given a collection of distinct integers, return all possible permutations. Example 1 2 3 4 5 6 7 8 9 10 Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] My Answer 재귀를 이용해서 해결 helper 함수에의 for구문에서 helper 함수를 재귀 호출 한다. helper 재귀 호출 하기...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/permutations/",
        "teaser":null},{
        "title": "Populating Next Right Pointers in Each Node",
        "excerpt":"Problem You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 1 2 3 4 5 6 struct Node { int val; Node *left; Node *right; Node *next; } Populate each next...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/populating_next_right_pointers_in_each_node/",
        "teaser":null},{
        "title": "Pow(x,n)",
        "excerpt":"Problem Implement pow(x, n), which calculates x raised to the power n (xn). Example 1 1 2 Input: 2.00000, 10 Output: 1024.00000 Example 2 1 2 Input: 2.10000, 3 Output: 9.26100 Example 3 1 2 3 Input: 2.00000, -2 Output: 0.25000 Explanation: 1/4 = 0.25 My Answer 1 2 3...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/pow/",
        "teaser":null},{
        "title": "Replace Words",
        "excerpt":"Problem In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another. Now, given a dictionary consisting of many roots...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/replace_words/",
        "teaser":null},{
        "title": "Reverse Bits",
        "excerpt":"Problem Reverse bits of a given 32 bits unsigned integer. Note Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/reverse_bits/",
        "teaser":null},{
        "title": "Reverse Linked List Iteratively",
        "excerpt":"Problem Reverse a singly linked list iteratively. Example 1 2 Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL My Answer cur 가 null이 아닐때 까지 순회돌자. prev에 cur을 할당하기 전까진 이전 노드를 가리키기 때문에, cur.next = prev를 하게 되면 현재 노드의 이전 노드를 다음 노드로 할당한다. 마지막 노드 까지 간 이후 while문을 나오게되면 현재...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/reverse_linked_list_iteratively/",
        "teaser":null},{
        "title": "Reverse Linked List Recursively",
        "excerpt":"Problem Reverse a singly linked list recursively. Example 1 2 Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL My Answer head.next == null 인 경우가 마지막 노드인데, 우린 마지막 노드를 Head로 사용 해야 한다. 이하 head로 되어 있지만, 그냥 cur(현재 처리 중인 노드)로 생각하는게, 이해하는데 도움 된다. cur.next는 현재 노드의 그 다음 노드를 가리키는데,...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/reverse_linked_list_recursively/",
        "teaser":null},{
        "title": "Reverse String Iteratively",
        "excerpt":"Problem Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/reverse_string_iteratively/",
        "teaser":null},{
        "title": "Reverse String Recursively",
        "excerpt":"Problem Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/reverse_string_recursively/",
        "teaser":null},{
        "title": "Search a 2D Matrix II",
        "excerpt":"Problem Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example 1 2 3...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/search_2d_matrix_ii/",
        "teaser":null},{
        "title": "Search for a Range",
        "excerpt":"Problem Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1 1 2...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/search_for_a_range/",
        "teaser":null},{
        "title": "Search in a Binary Search Tree",
        "excerpt":"Problem Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node’s value equals the given value. Return the subtree rooted with that node. If such node doesn’t exist, you should return NULL. Example 1 2...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/search_in_binary_search_tree/",
        "teaser":null},{
        "title": "Search in Rotated Sorted Array",
        "excerpt":"Problem Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array....","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/search_in_rotated_sorted_array/",
        "teaser":null},{
        "title": "Serialize and Deserialize Binary Tree",
        "excerpt":"Problem Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/serialize_deserialize_binarytree/",
        "teaser":null},{
        "title": "Single Number",
        "excerpt":"Problem Given a non-empty array of integers, every element appears twice except for one. Find that single one. Example 1 1 2 Input: [2,2,1] Output: 1 Example 2 1 2 Input: [4,1,2,1,2] Output: 4 My Answer 하나의 값을 제외한 나머지 값이 중복된다는 것을 이용해서 XOR연산을 이용하자. XOR연산의 특징이 A^A=0, A^0=A...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/single_number/",
        "teaser":null},{
        "title": "The Skyline Problem",
        "excerpt":"Problem A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/skyline_problem/",
        "teaser":null},{
        "title": "Sort an Array",
        "excerpt":"Problem Given an array of integers nums, sort the array in ascending order Example 1 1 2 Input: nums = [5,2,3,1] Output: [1,2,3,5] Example 2 1 2 Input: nums = [5,1,1,2,0,0] Output: [0,0,1,1,2,5] Constraints 1 2 1 &lt;= nums.length &lt;= 50000 -50000 &lt;= nums[i] &lt;= 50000 My Answer Divide and...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/sort_an_array/",
        "teaser":null},{
        "title": "Split Array Largest Sum",
        "excerpt":"Problem Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays. Example 1 2 3 4 5 6 7 8 9 10 11 Input: nums =...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/split_array_largest_sum/",
        "teaser":null},{
        "title": "Sqrt(x)",
        "excerpt":"Problem Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1 1 2 Input: 4...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/sqrt/",
        "teaser":null},{
        "title": "Sudoku Solver",
        "excerpt":"Problem Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/sudoku_solver/",
        "teaser":null},{
        "title": "Symmetric Tree",
        "excerpt":"Problem Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). Example 1 1 2 3 4 5 6 7 8 1 / \\ 2 2 / \\ / \\ 3 4 4 3 Input: [1,2,2,3,4,4,3] Output: true Example 2 1 2 3...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/symmetric_tree/",
        "teaser":null},{
        "title": "Two Sum",
        "excerpt":"Problem Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example 1 2 3 Input: [2, 7, 11, 15],...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/two_sum/",
        "teaser":null},{
        "title": "Two Sum II - Input array is sorted",
        "excerpt":"Problem Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/two_sum_ii_input_array_sorted/",
        "teaser":null},{
        "title": "Unique Binary Search Trees II",
        "excerpt":"Problem Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/unique_bst_ii/",
        "teaser":null},{
        "title": "Valid Perfect Square",
        "excerpt":"Problem Given a positive integer num, write a function which returns True if num is a perfect square else False. Example 1 1 2 Input: 16 Output: true Example 2 1 2 Input: 14 Output: false Note Do not use any built-in library function such as sqrt. My Answer 특정...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/valid_perfect_square/",
        "teaser":null},{
        "title": "Valid Sudoku",
        "excerpt":"Problem Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/valid_sudoku/",
        "teaser":null},{
        "title": "Validate Binary Search Tree",
        "excerpt":"Problem Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/validate_binary_search_tree/",
        "teaser":null},{
        "title": "What is Devide and Conquer",
        "excerpt":"Definition   재귀의 형태로 구현되는데 2개 이상의 작은 형태로 분할 해서 해결하는 방식   Flow      Divide : 문제  를 다음과 같이 여러개의 서브 문제로 분할 한다.    Conquer : 재귀적으로 서브 문제들을 해결한다.   Combine : 각 서브 문제들의 결과 값을 합친다.   ","categories": ["LeetCode"],
        "tags": ["LeetCode","Article"],
        "url": "/leetcode/what_is_devide_and_conquer/",
        "teaser":null},{
        "title": "What is Quick Sort",
        "excerpt":"Definition 이름 처럼 빠른 정렬 방식이고, Merge Sort에 비해 2~3배 빠르다. Flow 주어진 리스트를 2개로 나눌 pivot 값을 선정 한다. 하나의 서브 리스트에는 pivot 보다 작은 값들로만 구성되고, 다른 서브리스트에는 pivot과 동일하거나 큰 값으로 구성 한다. 이렇게 나누는 작업을 partitioning 이라 한다. pivot 값을 선정 하는 방식은 주어진 리스트의 첫번째...","categories": ["LeetCode"],
        "tags": ["LeetCode","Article"],
        "url": "/leetcode/what_is_quick_sort/",
        "teaser":null},{
        "title": "What is Recursion",
        "excerpt":"Definition 문제를 풀기 위한 접근방법중 하나로서, 함수 자기자신을 서브루틴 처럼 호출 하는 방식 Keywod base case : 추가적인 재귀호출없이 바로 결과를 연산해 내는 case, 재귀 호출의 가장 마지막 단계를 수행하는 호출. recurrence relation : 문제의 결과와 하위 문제들의 관계, base case에 도달 하기 위한 규칙 Example Pascal's Triangle이 재귀 호출의...","categories": ["LeetCode"],
        "tags": ["LeetCode","Article"],
        "url": "/leetcode/what_is_recursion/",
        "teaser":null},{
        "title": "Word Search II",
        "excerpt":"Problem Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/word_search_ii/",
        "teaser":null},{
        "title": "Top K Frequent Elements",
        "excerpt":"Problem Given a non-empty array of integers, return the k most frequent elements. Example 1 1 2 Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2 1 2 Input: nums = [1], k = 1 Output: [1] Note You may assume k is always valid, number of unique...","categories": ["LeetCode"],
        "tags": ["LeetCode","Java"],
        "url": "/leetcode/top_k_frequent_elements/",
        "teaser":null}]
